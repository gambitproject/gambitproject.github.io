# Google Summer of Code 2026

The Gambit project is sumbitting projects as an organization for [Google Summer of Code 2026](https://summerofcode.withgoogle.com/).
Prospective contributors interested in working with the Gambit team should read the "Contributor Guidance" and "Project Ideas" sections below.

> Google Summer of Code is a global, online program focused on bringing new contributors into open source software development. GSoC Contributors work with an open source organization on a 12+ week programming project under the guidance of mentors.

## Contributor Guidance

Please provide a CV and short cover letter. On your CV, include any relevant domain experience in game theory, and technical skills and experience in software engineering. We recommend to read through the Project Ideas below before submitting an application.

In your cover letter please include answers to the following questions:
1. What interests you most about the Gambit project?
2. Which specific project idea(s) are you most interested in and why?
    Note: While we do not rule out contributors proposing their own ideas, projects need to align with Gambit’s overall goals and must be feasible given the time available and your skills. Please cover how these aspects are met if you propose your own idea.
3. Please provide us with details of the times of day and days of the week you intend to work on the project, to help us in scheduling regular catch ups.
4. Is there anything that you’ll be studying or working on whilst working alongside us?

## Project Ideas

Prospective contributors should read through the project ideas listed below before submitting an application, following the Contributor Guidance above.
Select a project based on your research interests and the technical experience you have, or would like to develop.

#### Updating the Gambit GUI

Gambit’s graphical interface is the oldest part of the package.  It traces its origins to a MS-DOS based tool written in C++ using the Borland Graphics Interface (BGI) in the early 1990s. It was ported to wxWindows (now wxWidgets) in the mid-1990s, in the early days of that package.  Growing emphasis on scriptability and calculation at scale has meant the GUI has received less attention in recent years.  Nevertheless, it remains important to the package and the community as it is the point of entry for many users, either through use in teaching or in manually inputting small games for exploratory analysis.

In this project, we will modernise the implementation of the graphical interface.  This will involve a combination of several inter-related strands:

1. The history of development and maintenance of the GUI means it has not been modernised to use wxWidgets 3.x features, retaining a lot of history of 2.x (and in some places possibly even 1.x) style.  We will update the implementation to use modern wxWidgets and C++17 idioms.

2. The interaction design of the canvas used to display game trees, and the tables used to display games in normal form, is less than ideal, with features like drag-and-drop, scrolling, and so forth being sometimes unreliable.  These are due in part to legacy, in some cases dating back to the BGI implementation.  We will clean up the dated parts of the interface to an application that gives a more modern appearance.

3. When the GUI was invented it was not possible to do meaningful analysis of games much larger than could be drawn by hand. Today Gambit supports the analysis of huge (by comparison) games.  We will improve the scalability of the GUI to use the concepts we have developed for working with large games, including the ability to load and work with “standard” games from the extensive catalog of examples and benchmarks we have developed.

#### GameInterpreter: A front-end for LLM-based game translation tools

We have developed tools that leverage Large Language Models (LLMs) to translate natural language descriptions of games into formal game-theoretic models within Gambit. See, e.g.,

Shilong Deng, Yongzhao Wang, Rahul Savani:
*From Natural Language to Extensive-Form Game Representations*. **AAMAS 2025**: 593-601.

The method in that paper was called GameIntepreter v1; we are actively developing newer versions. In this project, a student would develop a front end that would allow users to explore the different versions of GameInterpreter.

#### A layout algorithm for visualising game trees

Extensive form game trees differ from other kinds of trees in graph theory due to the presence of information sets, which make drawing such trees a unique challenge not addressed by other software packages. In Game Theory, in any game with “imperfect information”, where some players are not fully informed about the state of the world, information sets group decision nodes based on the information available to players.

The Gambit project team have developed `draw_tree`, a Python package which works in tandem with `pygambit` (Gambit's Python implementation) to draw extensive form game trees. The package is already used in Gambit's Python tutorial documentation, but is also intended to be used for other purposes, in particular generating publication-ready images of game trees for research papers.

The best current layout algorithm used in `draw_tree` is based on code originally developed for Gambit's GUI software, which doesn't nicely render all the examples in Gambit's catalog of games, especially large ones with many information sets. The aim of the GSoC project would be to develop a new layout algorithm that can sensibly draw games of various sizes and complexity, including many information sets.

This project would suit someone who has a particular interest in visualisation challenges. For reference, check out the ["Stripped-down poker"](https://gambitproject.readthedocs.io/en/stable/tutorials/03_stripped_down_poker.html) tutorial from the `pygambit` documentation, which demonstrates how `pygambit` is used to construct, and `draw_tree` is used to visualise, a small extensive form game, including an explanation of the information sets present in the game.

#### Working on Gambit interoperability with SageMath

SageMath is a prominent open source mathematical software system. SageMath has some existing support for Game Theory, including some interoperability with Gambit version 15. There is a desire on both the Gambit and SageMath sides to improve interoperability and to get SageMath working fully with Gambit version 16.5 and later – see the following PR: https://github.com/sagemath/sage/pull/37809. In this project, a student would work to update that PR with a view to getting it merged by SageMath. In addition, a student could develop tutorials to demonstrate existing and new interoperability between Gambit and SageMath (see the following issue from Gambit’s repo: [#627](https://github.com/gambitproject/gambit/issues/627).

#### Updating how Gambit works with external solves

Many mathematical problems that arise in game theory can be expressed in standard formulations.  For example, there are many problems which can be expressed as linear programs, or the solutions to a system of polynomial equations and inequalities.  Gambit has routines for solving these problems; for example, Gambit has an internal LP solver, in part because it was not straightforward to call or link with external packages circa 1994!  In the modern scientific computing ecosystem, there are packages specialised to classes of mathematical programming or optimisation problems which will be far more performant.

Gambit currently has some very limited support for interfacing with some selected external tools via formulating the relevant problem in the file format required by that tool, running the tool, and then mapping the output back into game-theoretic objects.  This support is ad-hoc, and limited to certain tools - for example, at the moment Gambit does not have any support to use external LP solvers.

In this project, we will develop a better framework for this process of generating the problem instance and mapping the result back into Gambit objects, that will be more extensible to different project types and different external solvers.  In particular, as an important use case, we will develop the formulation of the linear programs that arise in several different places in game theory, and provide interfaces to different user-selectable LP solvers.

We are already aware from ad-hoc testing that in many cases the use of external solvers leads to huge performance gains, so success on this project would lead to a substantial increase in the size of game which is feasible to analyse.


#### Development and integration of package for Lemke's algorithm

Lemke’s algorithm is an important method in mathematical optimization for solving “Linear Complementarity Problems” (LCPs). Two player games, either in extensive or strategic form, the two primary game formats in Gambit, can be cast as LCPs solved using Lemke’s algorithm and variants of it. While Gambit has an in-built implementation of  Lemke’s algorithm in C++, we would like to integrate a python implementation of Lemke’s algorithm by Benrhard von Stengel.

The project would have two main parts:

1. Improve the “lemke” package, see https://github.com/gambitproject/lemke, and release it as a standalone LCP solver package. That package should support both standalone tools and be a callable library, for example with work needed on argument parsing (e.g. using the “click” package). There is also scope for also improving the code to be more pythonic. In addition, a test suite should be written for the package.

2. Integrate the new “lemke” package with core Gambit (https://github.com/gambitproject/gambit/), as an optional dependency, and alternative to the in-built Lemke solver. 
